#include <sys/types.h>
#include <pthread.h>
#include <sys/socket.h>
#include <stdio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <semaphore.h>
#include <fcntl.h>
#include <sys/shm.h>
#include "global_data.h"
#include <signal.h>

extern void read_cmd(char* cmd);
//extern struct move_info m_info;
extern void slist_delete(char* ip);
/////////////////////////////////////////
void* recv_info_thread(void* s)
{
	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL);
	pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,NULL);
	char buffer[ARRAY_SIZE];
	S_Params* sp=(S_Params*)s;
//	int optval;
//	socklen_t optlen = sizeof(int);
	while(1)
	{
		pthread_testcancel();
		memset(buffer,0,sizeof(buffer));
		int len = recv(sp->conn, buffer, sizeof(buffer),0);
		if(len>0)
			{
			if(strcmp(buffer,"exit")==0)
				{
				close(sp->conn);
				slist_delete(sp->ip);
				raise(SIGINT);
				break;
				}
			else
				{
				read_cmd(buffer);
				}
			}
		else
			{
			close(sp->conn);
			slist_delete(sp->ip);
			raise(SIGINT);
			break;
			}
	}
		printf("recv info thread is closed");
}
//////////////////////////////////////////////
int recong_info(int value)
{
int status=0;
if(value*1000)
return status;
}
///////////////////////////////////////////////
char* compile_info(int accel,int vel,)
{
char info[20];
info[0]='a';
memcpy(M_info_pointer,move_ll.M_Tail_pointer,M_NODE_SIZE);
switch(recong_info(m_info.accel))
{
	case 1:info[1]='0';info[2]='0';info[3]=m_info.accel+'0';break;
	case 2:info[1]='0';info[2]='0'+m_info.accel/10;
		info[3]=m_info.accel%10+'0';break;
	case 3:info[1]='0'+m_info/100;info[2]='0'+(m_info.accel%100)/10;
		info[3]=m_info.accel%10+'0';break;
	default:break;
}
info[4]='v';
switch(recong_info(m_info.vel))
{
	case 1:info[5]='0';info[6]='0';info[7]=m_info.vel+'0';break;
	case 2:info[5]='0';info[6]='0'+m_info.vel/10;
		info[7]=m_info.vel%10+'0';break;
	case 3:info[5]='0'+m_info/100;info[6]='0'+(m_info.vel%100)/10;
		info[7]=m_info.vel%10+'0';break;
	default:break;
}
info[8]='s';
switch(recong_info(m_info.journey))
{
	case 1:info[9]='0';info[10]='0';info[11]=m_info.journey+'0';break;
	case 2:info[9]='0';info[10]='0'+m_info.journey/10;
		info[11]=m_info.journey%10+'0';break;
	case 3:info[9]='0'+m_info/100;info[10]='0'+(m_info.journey%100)/10;
		info[11]=m_info.journey%10+'0';break;
	default:break;
}
info[12]='t';
switch(recong_info(m_info.temper))
{
	case 1:info[13]='0';info[14]='0';info[15]=m_info.temper+'0';break;
	case 2:info[13]='0';info[14]='0'+m_info.temper/10;
		info[15]=m_info.temper%10+'0';break;
	case 3:info[13]='0'+m_info/100;info[14]='0'+(m_info.temper%100)/10;
		info[15]=m_info.temper%10+'0';break;
	default:break;
}
info[16]='d';
switch(recong_info(m_info.dist))
{
	case 1:info[17]='0';info[18]='0';info[19]=m_info.dist+'0';break;
	case 2:info[17]='0';info[18]='0'+m_info.dist/10;
		info[19]=m_info.dist%10+'0';break;
	case 3:info[17]='0'+m_info/100;info[18]='0'+(m_info.dist%100)/10;
		info[19]=m_info.dist%10+'0';break;
	default:break;
}
return info;
}
//////////////////////////////////////////////
void* send_info_thread(void* s)
{
	char* buf;
	S_Params* sp=(S_Params*)s;
	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL);
	pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,NULL);
	while(1)
	{
		pthread_testcancel();
		buf=compile_info();
		if(send(sp->conn, buf, strlen(buf), 0)==-1)
		{
                        close(sp->conn);
                        slist_delete(sp->ip);
                        raise(SIGINT);
		} 
	}
}
